<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Block Visualizer</title>
    <style>
        .node text {
            font: 12px sans-serif;
            pointer-events: none;
        }

        .link {
            stroke: #999;
            stroke-opacity: 0.6;
        }

        svg {
            width: 100%;
            height: 600px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background: #fafafa;
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
<div id="block-graph"></div>
<script>
const graphData = {
    nodes: {{ nodes | tojson | safe }},
    edges: {{ edges | tojson | safe }},
    directed: {{ directed | tojson }}
};

// helper: wrap text within maxWidth
function wrapText(textSelection, maxWidth) {
    textSelection.each(function() {
        const text = d3.select(this);
        const words = text.text().split(/\s+/).reverse();
        let word, line = [], lineNumber = 0;
        const lineHeight = 1.1; // ems
        const y = text.attr("y");
        const x = text.attr("x");
        const dy = 0;

        let tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");

        while (word = words.pop()) {
            line.push(word);
            tspan.text(line.join(" "));
            if (tspan.node().getComputedTextLength() > maxWidth) {
                line.pop();
                tspan.text(line.join(" "));
                line = [word];
                tspan = text.append("tspan")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("dy", ++lineNumber * lineHeight + "em")
                    .text(word);
            }
        }
    });
}

// normalize edges (avoid duplicates)
function normalizeEdges(nodes, edges) {
    const links = [];
    const seen = new Set();

    edges.forEach(e => {
        const src = nodes.find(n => n.id === e.source);
        const tgt = nodes.find(n => n.id === e.target);
        if (!src || !tgt) return;

        const key1 = `${src.id}->${tgt.id}`;
        const key2 = `${tgt.id}->${src.id}`;

        if (!seen.has(key1)) {
            links.push({source: src, target: tgt});
            seen.add(key1);
        }
        if (graphData.directed === false && !seen.has(key2) &&
            edges.find(x => x.source === tgt.id && x.target === src.id)) {
            links.push({source: tgt, target: src});
            seen.add(key2);
        }
    });

    return links;
}

function fitGraphToView(svg, container, nodes, width, height, padding = 50) {
    // Wait for the simulation to settle
    setTimeout(() => {
        if (nodes.length === 0) return;

        // Calculate bounding box of all nodes
        const nodeBounds = nodes.map(n => ({
            x: n.x,
            y: n.y,
            width: n.blockWidth,
            height: n.blockHeight
        }));

        const minX = Math.min(...nodeBounds.map(n => n.x - n.width/2));
        const maxX = Math.max(...nodeBounds.map(n => n.x + n.width/2));
        const minY = Math.min(...nodeBounds.map(n => n.y - n.height/2));
        const maxY = Math.max(...nodeBounds.map(n => n.y + n.height/2));

        const graphWidth = maxX - minX;
        const graphHeight = maxY - minY;

        // Calculate scale to fit the graph with padding
        const scaleX = (width - 2 * padding) / graphWidth;
        const scaleY = (height - 2 * padding) / graphHeight;
        const scale = Math.min(scaleX, scaleY, 1); // Don't zoom in beyond 100%

        // Calculate center position
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        // Calculate translation to center the graph
        const translateX = width / 2 - centerX * scale;
        const translateY = height / 2 - centerY * scale;

        // Apply the transformation
        const transform = d3.zoomIdentity
            .translate(translateX, translateY)
            .scale(scale);

        svg.call(svg.__zoom.transform, transform);
    }, 2000); // Wait for simulation to stabilize
}

function renderBlockGraph(data) {
    const width = 1000, height = 600;

    // precompute node sizes
    data.nodes.forEach(n => {
        n.attrs = Object.entries(n.data || {});
        n.blockWidth = 200;
        n.blockHeight = 20 * (n.attrs.length + 1) + 20;
        n.blockDiagonal = Math.sqrt(n.blockWidth**2 + n.blockHeight**2);
    });

    const links = normalizeEdges(data.nodes, data.edges);

    const zoom = d3.zoom()
        .scaleExtent([0.1, 4])
        .on("zoom", (event) => container.attr("transform", event.transform));

    const svg = d3.select("#block-graph")
        .append("svg")
        .attr("viewBox", `0 0 ${width} ${height}`)
        .attr("preserveAspectRatio", "xMidYMid meet")
        .call(zoom);

    // Store zoom behavior for later use
    svg.__zoom = zoom;

    const container = svg.append("g");

    // add arrow marker only if directed
    if (data.directed) {
        svg.append("defs").append("marker")
            .attr("id", "arrow")
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 70)
            .attr("refY", 0)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", "#999");
    }

    const simulation = d3.forceSimulation(data.nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(200))
        .force("charge", d3.forceManyBody().strength(-800))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("collision", d3.forceCollide().radius(d => d.blockDiagonal / 2 + 20));

    const link = container.append("g")
        .attr("class", "links")
        .selectAll("line")
        .data(links)
        .enter()
        .append("line")
        .attr("stroke-width", 2)
        .attr("stroke", "#999")
        .attr("marker-end", data.directed ? "url(#arrow)" : null);

    const node = container.append("g")
        .attr("class", "nodes")
        .selectAll("g")
        .data(data.nodes)
        .enter()
        .append("g")
        .call(drag(simulation));

    node.each(function(d) {
        const g = d3.select(this);

        g.append("rect")
            .attr("width", d.blockWidth)
            .attr("height", d.blockHeight)
            .attr("x", -d.blockWidth/2)
            .attr("y", -d.blockHeight/2)
            .attr("fill", "#fff")
            .attr("stroke", "#000")
            .attr("rx", 5)
            .attr("ry", 5);

        g.append("rect")
            .attr("width", d.blockWidth)
            .attr("height", 25)
            .attr("x", -d.blockWidth/2)
            .attr("y", -d.blockHeight/2)
            .attr("fill", "#f8adbb")
            .attr("rx", 5)
            .attr("ry", 5);

        g.append("text")
            .attr("x", 0)
            .attr("y", -d.blockHeight/2 + 17)
            .text(`ID: ${d.id}`)
            .attr("font-size", "12px")
            .attr("font-weight", "bold")
            .attr("fill", "#000")
            .attr("text-anchor", "middle");

        g.selectAll(".attrText")
            .data(d.attrs)
            .enter()
            .append("text")
            .attr("class", "attrText")
            .attr("x", -d.blockWidth/2 + 5)
            .attr("y", (attr, i) => -d.blockHeight/2 + 40 + i * 20)
            .text(attr => `${attr[0]}: ${attr[1]}`)
            .attr("font-size", "12px")
            .attr("fill", "#000")
            .each(function() { wrapText(d3.select(this), d.blockWidth+ 40); });
    });

    simulation.on("tick", () => {
        link
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

        node.attr("transform", d => `translate(${d.x},${d.y})`);
    });

    // Also fit after a delay as backup
    fitGraphToView(svg, container, data.nodes, width, height);

    function drag(simulation) {
        return d3.drag()
            .on("start", (event, d) => {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            })
            .on("drag", (event, d) => {
                d.fx = event.x;
                d.fy = event.y;
            })
            .on("end", (event, d) => {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            });
    }
}

renderBlockGraph(graphData);
</script>
</body>
</html>