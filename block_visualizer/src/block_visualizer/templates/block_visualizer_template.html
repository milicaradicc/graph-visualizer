<style>
#block_visualizer {
    width: 100%;
    height: 100%;
    display: block !important;

    .node text {
    font: 12px sans-serif;
    pointer-events: none;
}
.node {
    cursor: pointer;
}

.node:hover {
    fill: #f5f5f5;
    stroke-width: 3px;
}
.link {
    stroke: #999;
    stroke-opacity: 0.6;
}
}
</style>

<div style="width: 100%; height: 100%; position: relative;">
    <svg id="block_visualizer"></svg>
</div>

<script>
function wrapText(textSelection, maxWidth) {
    textSelection.each(function() {
        const text = d3.select(this);
        const words = text.text().split(/\s+/).reverse();
        let word, line = [], lineNumber = 0;
        const lineHeight = 1.1; // ems
        const y = text.attr("y");
        const x = text.attr("x");
        const dy = 0;

        let tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");

        while (word = words.pop()) {
            line.push(word);
            tspan.text(line.join(" "));
            if (tspan.node().getComputedTextLength() > maxWidth) {
                line.pop();
                tspan.text(line.join(" "));
                line = [word];
                tspan = text.append("tspan")
                    .attr("x", x)
                    .attr("y", y)
                    .attr("dy", ++lineNumber * lineHeight + "em")
                    .text(word);
            }
        }
    });
}

function normalizeEdges(nodes, edges, isDirected) {
    const links = [];
    const seen = new Set();

    edges.forEach(e => {
        const src = nodes.find(n => n.id === e.source);
        const tgt = nodes.find(n => n.id === e.target);
        if (!src || !tgt) return;

        const key1 = `${src.id}->${tgt.id}`;
        const key2 = `${tgt.id}->${src.id}`;

        if (!seen.has(key1)) {
            links.push({source: src, target: tgt});
            seen.add(key1);
        }
        if (isDirected === false && !seen.has(key2) &&
            edges.find(x => x.source === tgt.id && x.target === src.id)) {
            links.push({source: tgt, target: src});
            seen.add(key2);
        }
    });

    return links;
}

function renderBlockGraph() {
    const data = {
         nodes: {{ nodes | tojson | safe }},
         edges: {{ edges | tojson | safe }},
         directed: {{ directed | tojson }}
     };
    const width = 800;
    const height = 600;
    
    // Check if we have valid data
    if (!data || !data.nodes || data.nodes.length === 0) {
        console.error('No valid node data provided to renderBlockGraph');
        return null;
    }

    // precompute node sizes
    data.nodes.forEach(n => {
        n.attrs = Object.entries(n.data || {});
        n.blockWidth = 200;
        n.blockHeight = 20 * (n.attrs.length + 1) + 20;
        n.blockDiagonal = Math.sqrt(n.blockWidth**2 + n.blockHeight**2);
    });

    const links = normalizeEdges(data.nodes, data.edges || [], data.directed);

    const svg = d3.select("#block_visualizer")
        .attr("viewBox", `0 0 ${width} ${height}`)
        .attr("preserveAspectRatio", "xMidYMid meet")
        .style("width", "100%")
        .style("height", "100%");

    svg.selectAll("*").remove();

    const container = svg.append("g").attr("class", "visualization-container");

    const markerId = `arrowhead-block`;
    if (data.directed) {
        svg.append("defs").append("marker")
            .attr("id", markerId)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", 100)
            .attr("refY", 0)
            .attr("markerWidth", 9)
            .attr("markerHeight", 9)
            .attr("orient", "auto")
            .attr("markerUnits", "userSpaceOnUse")
            .append("path")
            .attr("d", "M0,-5L10,0L0,5")
            .attr("fill", "#999");
    }

    const linkSelection = container.selectAll(".link")
        .data(links)
        .enter()
        .append("path")
        .attr("class", "links")
        .attr("enabled", "true")
        .attr("fill", "none")
        .attr("stroke-width", 2)
        .attr("stroke", "#999")
        .attr("marker-end", data.directed ? `url(#${markerId})` : null);

    const nodeGroups = container.selectAll(".node-group")
        .data(data.nodes)
        .enter()
        .append("g")
        .attr("class", "node-group")
        .attr("enabled", "true");

    nodeGroups.each(function(d) {
        const g = d3.select(this);

        g.append("rect")
            .attr("class", "node")
            .attr("enabled", "true")
            .attr("width", d.blockWidth)
            .attr("height", d.blockHeight)
            .attr("x", -d.blockWidth/2)
            .attr("y", -d.blockHeight/2)
            .attr("fill", "#fff")
            .attr("stroke", "#000")
            .attr("rx", 5)
            .attr("ry", 5)
            .attr("id", d.id);

        g.append("rect")
            .attr("width", d.blockWidth)
            .attr("height", 25)
            .attr("x", -d.blockWidth/2)
            .attr("y", -d.blockHeight/2)
            .attr("fill", "#f8adbb")
            .attr("rx", 5)
            .attr("ry", 5);
    });

    const textSelection = nodeGroups
        .append("text")
        .attr("class", "node-label")
        .text(d => `ID: ${d.id}`)
        .attr("x", 0)
        .attr("y", d => -d.blockHeight/2 + 17)
        .attr("font-size", "12px")
        .attr("font-weight", "bold")
        .attr("fill", "#000")
        .attr("text-anchor", "middle");

    nodeGroups.each(function(d) {
        const g = d3.select(this);

        g.selectAll(".attrText")
            .data(d.attrs)
            .enter()
            .append("text")
            .attr("class", "attrText")
            .attr("x", -d.blockWidth/2 + 5)
            .attr("y", (attr, i) => -d.blockHeight/2 + 40 + i * 18)
            .text(attr => `${attr[0]}: ${attr[1] != null ? attr[1].toString() : ''}`)
            .attr("font-size", "12px")
            .attr("fill", "#000")
            .each(function() {
                wrapText(d3.select(this), d.blockWidth - 10);
            });
    });
}

renderBlockGraph();

</script>